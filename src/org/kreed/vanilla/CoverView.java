/*
 * Copyright (C) 2010, 2011 Christopher Eby <kreed@kreed.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package org.kreed.vanilla;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.LinearGradient;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.Shader;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewConfiguration;
import android.widget.Scroller;

/**
 * Displays a flingable/draggable View of cover art/song info images
 * generated by CoverBitmap.
 */
public final class CoverView extends View implements Handler.Callback {
	/**
	 * The system-provided snap velocity, used as a threshold for detecting
	 * flings.
	 */
	private static int sSnapVelocity = -1;
	/**
	 * Display metrics, used for scaling.
	 */
	private static DisplayMetrics sDisplayMetrics;
	/**
	 * The Handler with which to do background work. Will be null until
	 * setupHandler is called.
	 */
	private Handler mHandler;
	/**
	 * A handler running on the UI thread, for UI operations.
	 */
	private final Handler mUiHandler = new Handler(this);
	/**
	 * Interface to respond to CoverView motion actions.
	 */
	public interface Callback {
		/**
		 * Called after the view has scrolled to the next or previous cover.
		 *
		 * @param delta -1 for the previous cover, 1 for the next.
		 */
		public void shiftCurrentSong(int delta);
		/**
		 * Called when the user has swiped up on the view.
		 */
		public void upSwipe();
		/**
		 * Called when the user had swiped down on the view.
		 */
		public void downSwipe();
	}
	/**
	 * The instance of the callback.
	 */
	private Callback mCallback;
	/**
	 * The current set of songs: 0 = previous, 1 = current, and 2 = next.
	 */
	private final Song[] mSongs = new Song[3];
	/**
	 * Cover art for each song in mSongs.
	 */
	private final Bitmap[] mCoverArt = new Bitmap[3];
	/**
	 * Cover art to use when a song has no cover art in no info display styles.
	 */
	private Bitmap mDefaultCover;
	/**
	 * Computes scroll animations.
	 */
	private final Scroller mScroller;
	/**
	 * Computes scroll velocity to detect flings.
	 */
	private VelocityTracker mVelocityTracker;
	/**
	 * The x coordinate of the last touch down or move event.
	 */
	private float mLastMotionX;
	/**
	 * The y coordinate of the last touch down or move event.
	 */
	private float mLastMotionY;
	/**
	 * The x coordinate of the last touch down event.
	 */
	private float mStartX;
	/**
	 * The y coordinate of the last touch down event.
	 */
	private float mStartY;
	/**
	 * The index of the cover that is being scrolled to during a fling
	 * animation, or -1 if the cover is the active (middle) cover.
	 */
	private int mTentativeCover = -1;
	/**
	 * Ignore the next pointer up event, for long presses.
	 */
	private boolean mIgnoreNextUp;
	/**
	 * If true, querySongs was called before the view initialized and should
	 * be called when initialization finishes.
	 */
	private boolean mPendingQuery;
	/**
	 * If true, calls to invalidate() will do nothing. We use this so we can
	 * only invalidate the dirty rect during scrolling.
	 */
	private boolean mSuppressInvalidate;

	/**
	 * Constructor intended to be called by inflating from XML.
	 */
	public CoverView(Context context, AttributeSet attributes)
	{
		super(context, attributes);

		mScroller = new Scroller(context);

		if (sSnapVelocity == -1) {
			sSnapVelocity = ViewConfiguration.get(context).getScaledMinimumFlingVelocity();
			sDisplayMetrics = context.getResources().getDisplayMetrics();
		}
	}

	/**
	 * Setup the Handler and callback. This must be called before
	 * the CoverView is used.
	 *
	 * @param looper A looper created on a worker thread.
	 * @param callback The callback for nextSong/previousSong
	 */
	public void setup(Looper looper, Callback callback)
	{
		mHandler = new Handler(looper, this);
		mCallback = callback;
	}

	/**
	 * Reset the scroll position to its default state.
	 */
	private void resetScroll()
	{
		if (!mScroller.isFinished())
			mScroller.abortAnimation();
		scrollTo(getWidth(), 0);
	}

	@Override
	protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight)
	{
		if (mPendingQuery && width != 0 && height != 0) {
			mPendingQuery = false;
			querySongs(PlaybackService.get(getContext()));
		}
	}

	/**
	 * Paint the cover art views to the canvas.
	 */
	@Override
	protected void onDraw(Canvas canvas)
	{
		int width = getWidth();
		int height = getHeight();
		int x = 0;
		int scrollX = getScrollX();
		Rect dest = new Rect();

		canvas.drawColor(Color.BLACK);

		for (Bitmap bitmap : mCoverArt) {
			if (bitmap != null && scrollX + width > x && scrollX < x + width) {
				int bitmapWidth = bitmap.getWidth();
				int bitmapHeight = bitmap.getHeight();
				float scale = Math.min((float)width / bitmapWidth, (float)height / bitmapHeight);
				bitmapWidth *= scale;
				bitmapHeight *= scale;
				dest.left = x + (width - bitmapWidth) / 2;
				dest.right = dest.left + bitmapWidth;
				dest.top = (height - bitmapHeight) / 2;
				dest.bottom = dest.top + bitmapHeight;
				canvas.drawBitmap(bitmap, null, dest, null);
			}
			x += width;
		}
	}

	/**
	 * Scrolls the view when dragged. Animates a fling to one of the three covers
	 * when finished. The cover flung to will be either the nearest cover, or if
	 * the fling is fast enough, the cover in the direction of the fling.
	 *
	 * Also performs a click on the view when it is tapped without dragging.
	 */
	@Override
	public boolean onTouchEvent(MotionEvent ev)
	{
		if (mVelocityTracker == null)
			mVelocityTracker = VelocityTracker.obtain();
		mVelocityTracker.addMovement(ev);

		float x = ev.getX();
		float y = ev.getY();
		int scrollX = getScrollX();
		int width = getWidth();

		switch (ev.getAction()) {
		case MotionEvent.ACTION_DOWN:
			if (!mScroller.isFinished())
				mScroller.abortAnimation();

			mStartX = x;
			mStartY = y;
			mLastMotionX = x;
			mLastMotionY = y;

			mUiHandler.sendEmptyMessageDelayed(MSG_LONG_CLICK, ViewConfiguration.getLongPressTimeout());
			break;
		case MotionEvent.ACTION_MOVE: {
			float deltaX = mLastMotionX - x;
			float deltaY = mLastMotionY - y;

			if (Math.abs(deltaX) > Math.abs(deltaY)) {
				if (deltaX < 0) {
					int availableToScroll = scrollX - (mSongs[0] == null ? width : 0);
					if (availableToScroll > 0)
						scrollBy(Math.max(-availableToScroll, (int)deltaX), 0);
				} else if (deltaX > 0) {
					int availableToScroll = width * 2 - scrollX;
					if (availableToScroll > 0)
						scrollBy(Math.min(availableToScroll, (int)deltaX), 0);
				}
			}

			mLastMotionX = x;
			mLastMotionY = y;
			break;
		}
		case MotionEvent.ACTION_UP: {
			mUiHandler.removeMessages(MSG_LONG_CLICK);

			VelocityTracker velocityTracker = mVelocityTracker;
			velocityTracker.computeCurrentVelocity(250);
			int velocityX = (int) velocityTracker.getXVelocity();
			int velocityY = (int) velocityTracker.getYVelocity();
			int mvx = Math.abs(velocityX);
			int mvy = Math.abs(velocityY);

			int min = mSongs[0] == null ? 1 : 0;
			int max = 2;

			int whichCover = 1;

			if (Math.abs(mStartX - x) + Math.abs(mStartY - y) < 10) {
				// A long press was performed and thus the normal action should
				// not be executed.
				if (mIgnoreNextUp)
					mIgnoreNextUp = false;
				else
					performClick();
				whichCover = 1;
			} else if (mvx > sSnapVelocity || mvy > sSnapVelocity) {
				if (mvy > mvx) {
					if (velocityY > 0)
						mCallback.downSwipe();
					else
						mCallback.upSwipe();
				} else {
					if (velocityX > 0)
						whichCover = min;
					else
						whichCover = max;
				}
			} else {
				int nearestCover = (scrollX + width / 2) / width;
				whichCover = Math.max(min, Math.min(nearestCover, max));
			}

			int newX = whichCover * width;
			int delta = newX - scrollX;
			mScroller.startScroll(scrollX, 0, delta, 0, (int)(Math.abs(delta) * 2 / sDisplayMetrics.density));
			if (whichCover != 1)
				mTentativeCover = whichCover;

			mUiHandler.sendEmptyMessage(MSG_SCROLL);

			if (mVelocityTracker != null) {
				mVelocityTracker.recycle();
				mVelocityTracker = null;
			}

			break;
		}
		}
		return true;
	}

	/**
	 * Fetches cover art from the MediaStore for the song at the given position.
	 *
	 * @param i The position of the song in mSongs.
	 */
	private void fetchCover(int i)
	{
		Song song = mSongs[i];
		if (song == null)
			return;

		Bitmap bitmap = song.getCover(getContext());
		if (bitmap == null) {
			if (mDefaultCover == null)
				mDefaultCover = generateDefaultCover();
			bitmap = mDefaultCover;
		}

		mCoverArt[i] = bitmap;
		postInvalidate();
	}

	/**
	 * Set the Song at position <code>i</code> to <code>song</code>, generating
	 * the bitmap for it in the background if needed.
	 */
	public void setSong(int i, Song song)
	{
		mSongs[i] = song;
		if (song == null || song.hasNoCover()) {
			if (mDefaultCover == null)
				mDefaultCover = generateDefaultCover();
			mCoverArt[i] = mDefaultCover;
		} else {
			Bitmap bitmap = song.getCachedCover();
			if (bitmap == null) {
				mHandler.sendMessage(mHandler.obtainMessage(MSG_FETCH_COVER, i, 0));
			} else {
				mCoverArt[i] = bitmap;
			}
		}
	}

	/**
	 * Query all songs. Must be called on the UI thread.
	 *
	 * @param service Service to query from.
	 */
	public void querySongs(PlaybackService service)
	{
		if (getWidth() == 0 || getHeight() == 0) {
			mPendingQuery = true;
			return;
		}

		mHandler.removeMessages(MSG_FETCH_COVER);
		setSong(1, service.getSong(0));
		setSong(2, service.getSong(1));
		setSong(0, service.getSong(-1));
		resetScroll();
		invalidate();
	}

	/**
	 * Call {@link CoverView#fetchCover(int)} with arg1 as the argument.
	 */
	private static final int MSG_FETCH_COVER = 0;
	/**
	 * Perform a long click.
	 *
	 * @see View#performLongClick()
	 */
	private static final int MSG_LONG_CLICK = 2;
	/**
	 * Update position for fling scroll animation and, when it is finished,
	 * notify PlaybackService that the user has requested a track change and
	 * update the cover art views. Will resend message until scrolling is
	 * finished.
	 */
	private static final int MSG_SCROLL = 3;

	@Override
	public boolean handleMessage(Message message)
	{
		switch (message.what) {
		case MSG_FETCH_COVER:
			fetchCover(message.arg1);
			break;
		case MSG_LONG_CLICK:
			if (Math.abs(mStartX - mLastMotionX) + Math.abs(mStartY - mLastMotionY) < 10) {
				mIgnoreNextUp = true;
				performLongClick();
			}
			break;
		case MSG_SCROLL:
			if (mScroller.computeScrollOffset()) {
				// scrollTo calls invalidate(), however, we want to invalidate
				// only the region where the covers are drawn, so we need to
				// suppress this call.
				mSuppressInvalidate = true;
				scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
				mSuppressInvalidate = false;

				invalidateCovers();
				mUiHandler.sendEmptyMessage(MSG_SCROLL);
			} else if (mTentativeCover != -1) {
				mCallback.shiftCurrentSong(mTentativeCover - 1);
				mTentativeCover = -1;
				resetScroll();
			}
			break;
		default:
			return false;
		}

		return true;
	}

	/**
	 * Overridden to allow redraws to be suppressed.
	 */
	@Override
	public void invalidate()
	{
		if (!mSuppressInvalidate)
			super.invalidate();
	}

	/**
	 * Call {@link View#invalidate(int,int,int,int)} with the area
	 * containing the visible cover(s).
	 */
	public void invalidateCovers()
	{
		int width = getWidth();
		int height = getHeight();
		int scrollX = getScrollX();
		int x = 0;
		int maxHeight = 0;

		for (Bitmap bitmap : mCoverArt) {
			if (bitmap != null && scrollX + width > x && scrollX < x + width) {
				int bitmapHeight = bitmap.getHeight();
				if (bitmapHeight > maxHeight) {
					maxHeight = bitmapHeight;
				}
			}
			x += width;
		}

		int offset = (height - maxHeight) / 2;
		invalidate(scrollX, offset, scrollX + width, height - offset);
	}

	/**
	 * Generate the default cover (a rendition of a CD).
	 *
	 * @return A bitmap of the default cover.
	 */
	public Bitmap generateDefaultCover()
	{
		int size = Math.min(getWidth(), getHeight());
		int halfSize = size / 2;
		int eightSize = size / 8;

		Bitmap bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.RGB_565);
		LinearGradient gradient = new LinearGradient(size, 0, 0, size, 0xff646464, 0xff464646, Shader.TileMode.CLAMP);
		RectF oval = new RectF(eightSize, 0, size - eightSize, size);

		Paint paint = new Paint();
		paint.setAntiAlias(true);

		Canvas canvas = new Canvas(bitmap);
		canvas.rotate(-45, halfSize, halfSize);

		paint.setShader(gradient);
		canvas.translate(size / 20, size / 20);
		canvas.scale(0.9f, 0.9f);
		canvas.drawOval(oval, paint);

		paint.setShader(null);
		paint.setColor(0xff000000);
		canvas.translate(size / 3, size / 3);
		canvas.scale(0.333f, 0.333f);
		canvas.drawOval(oval, paint);

		paint.setShader(gradient);
		canvas.translate(size / 3, size / 3);
		canvas.scale(0.333f, 0.333f);
		canvas.drawOval(oval, paint);

		return bitmap;
	}
}
